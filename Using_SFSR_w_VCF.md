# Using the SFSR package with VCF Files

##### Authors
Liz Cooper
November 2017

Original Creator of sfsr:
Andrew Parker Morgan, 2016
https://github.com/andrewparkermorgan/sfsr

#### Description
The original sfsr package was created as a set of simple utilities for
working with allele frequency spectra (aka "site frequency spectra", SFS) in order to run classic population
genetics tests such as Tajima's D, HKA, Fu and Li's D, etc.

Modifications made for this version include additional functions to
enable VCF input  (a standard format for genetic variation data
generated by Next-Gen pipelines), as well a new function to calculate
Fay and Wu's H.

### Loading the Package
In order to install the sfsr package from GitHub, you **must** first have
the package `devtools` installed.  If you have not done this already,
use:

	install.packages("devtools")

To install sfsr and load its functions:

	library(devtools)
	install_github("eacooper400/sfsr")
	library(sfsr)


### Read in Sample VCF data and Construct SFS
For convenience, I've copied a `read.vcf()` function into this
package, so you can use it to read a VCF file into an R data.frame
object:

	my.data=read.vcf("sampleData_Tajima.vcf", header=TRUE, stringsAsFactors=FALSE)
	dim(my.data)
	[1] 1098  364

Next, to construct an SFS (Site Frequency Spectrum) object:

	sfs = sfs.fromVcf(list(my.data))

The above command will create a 1-dimensional SFS (which can be used
in any test).  *Some* tests can also make use of a 2-dimensional joint
frequency spectrum.  To create a 2D SFS, you should first split your
data into 2 VCF files, 1 for each group/population:

	pop1.data = my.data[, -c(60:ncol(my.data))]
	pop2.data = my.data[, -c(10:59, 110:ncol(my.data))]

	dim(pop1.data)
	[1] 1098   59
	dim(pop2.data)
	[1] 1098   59

	sfs.2d = sfs.fromVcf(list(pop1.data, pop2.data))

*Note that the population sizes do not have to be the same.*

### Calculating Tajima's D, Fu and Li's D and F, and Fay and Wu's H
Different estimators of the population mutation rate (theta) will be
differently affected by changes in the site frequency spectrum, and
each of these statistics measures that in some way in order to detect
the potential effects of selection.

#### Tajima's D
Tajima's D is the most classic of these estimators; it quantifies the
difference between Waterson's theta (calculated based on the number of
segregating sites) and Pi (calculated based on the average number of
pairwise differences).

	tajimaD(sfs)
	[1] -1.507416

While this measure is useful for distinguishing between directional
selection (negative values) and balancing selection (positive values);
it does not distinguish between positive and negative directional
selection, because it does not distinguish between ancestral and
derived alleles.

#### Fu and Li's D and F:
Both of these statistics count the number of derived singletons
(alleles that appear only once in the population), and compare this
count to either Waterson's theta (D) or Pi (F).

	fuliD(sfs)
	[1] 0.1109714
	fuliF(sfs)
	[1] -0.990409

#### Fay and Wu's H:
*H* also uses the frequency of derived sites; it compares the number
of high frequency derived alleles to the number of intermediate
frequency sites:

	fayWu_H(sfs)
	[1] -0.3439132

### Performing the HKA Test
To run the HKA test, you want to have **at least** 2 loci that you are
trying to compare: 1 that will be treated as your "neutral" locus, and
one where you want to test for departures from neutrality.

	loc_neut = subset(my.data, (my.data$POS>=68023734 & my.data$POS<=68024960))
	loc_sel = subset(my.data, (my.data$POS>=68034103 & my.data$POS<=68036074))

	sfs_neut=sfs_neut=sfs.fromVcf(list(loc_neut))
	sfs_sel=sfs.fromVcf(list(loc_sel))

	hka_test(sfs_neut, sfs_sel)

